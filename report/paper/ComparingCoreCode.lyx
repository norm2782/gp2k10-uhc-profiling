#LyX 2.0.0beta1 created this file. For more info see http://www.lyx.org/
\lyxformat 407
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_xetex false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Analyzing Core and Grin Code
\begin_inset CommandInset label
LatexCommand label
name "sec:Analyzing-Core-and"

\end_inset


\end_layout

\begin_layout Standard
In this section we will analyze the intermediate stages of compilation in
 order to get a better understanding of how the compiler transforms the
 code.
\end_layout

\begin_layout Standard
During compilation, Haskell code is converted to C in several steps
\begin_inset CommandInset citation
LatexCommand cite
key "Dijkstra:2007p590,Dijkstra:2009p587"

\end_inset

.
 In the first step, Haskell code is converted to a desugared Haskell, called
 Essential Haskell (EH).
 Next, the EH is converted to Core code--an un-typed lambda calculus--in
 multiple passes.
 After the code has been fully converted to Core, the Core code is transformed
 into a Grin (Graph reduction intermediate notation) representation, again
 in multiple steps.
 From here, the code can either be converted to directly to C, or it can
 be transformed to LLVM, via a stage called Silly.
 In this section, we are only concerned with the Core and Grin stages.
\end_layout

\begin_layout Subsection
Approach
\end_layout

\begin_layout Standard
For comparing Core and Grin code, intermediate compilation steps need to
 be saved by the compiler.
 To achieve this for UHC, it has to be compiled in a debug configuration.
 Variant 99 is used for this research, which includes all UHC features,
 including debugging and tracing support.
 
\end_layout

\begin_layout Standard
By specifying the 
\family typewriter
--dump-core-stages=1
\family default
 and 
\family typewriter
--dump-grin-stages=1
\family default
 flags, UHC dumps all intermediate Core and Grin stages in the same directory
 as the compiled source file.
 The files generated by UHC can be viewed with any text editor.
 For these purposes, the FileMerge application on Mac OS X is used to provide
 a visual diff between two files.
\end_layout

\begin_layout Standard
For each data type, a total of three files are compiled, each of which is
 compiled with all optimization levels; O0, O1, O2 and O3.
 One file contains a data type which derives a class instance, another file
 contains a data type and a manually implemented class instance, and the
 last one contains a data type with a manually implemented class instances
 and the 
\family typewriter
{-# LANGUAGE NoGenericDeriving #-}
\family default
 pragma.
 This pragma prevents the generation of generic code, since the generic
 code is not used in the files containing manual class instances.
\end_layout

\begin_layout Subsection
Observations
\end_layout

\begin_layout Standard
On optimization levels O0 to O2, a total of sixteen core passes is executed.
 Regardless of optimization level, the code after the last pass is always
 the same for the same file.
 Only optimization level O3 adds a seventeenth pass, which alters the code
 more.
\end_layout

\begin_layout Standard
The files without the explicit 
\family typewriter
NoGenericDeriving
\family default
 pragma still contain generic representations and embedding projection pairs
 after all core passes and all Grin passes, even on the highest optimization
 levels.
 In the file with the explicit pragma, generic code is never added.
\end_layout

\begin_layout Subsection
Discussion
\end_layout

\begin_layout Standard
Even though the generic code is never used in the non-generic code without
 the 
\family typewriter
NoGenericDeriving
\family default
 pragma, UHC does not remove it during optimization.
 While this might lead to extra space overhead, tests have shown that the
 presence does not impact performance.
 For this reason, no further explicit difference will be made between code
 tested with 
\family typewriter
NoGenericDeriving
\family default
 and without this pragma.
\end_layout

\end_body
\end_document
